
// Copyright notice:

/*--------------------------------------------------------------------------------------------- 
* Original work: Copyright (c) 2020-2021 Refloow All rights reserved.

* Code origin: https://github.com/OSL-Works/Steam-Card-Bot-PRO
* Developer name: Veljko Vuckovic
* Licensed under the MIT License. See LICENSE in the project root for license information.
* Published License: https://github.com/OSL-Works/Steam-Card-Bot-PRO/master/LICENSE

* Contact information:
  Discord Support Server: https://discord.gg/D8WCtDD
  Main developer steam: https://steamcommunity.com/id/MajokingGames/ 
  Mail: refloowlibrarycontact@gmail.com

* Donations:
  Crypto: https://refloow.com/cdonate
  Steam: https://steamcommunity.com/tradeoffer/new/?partner=392773011&token=CncehZti
 --------------------------------------------------------------------------------------------*/

 /* 

// legal advice: PERMISSIONS AND RIGHTS

* License does not prohibit modification, distribution, private/commercial use or sale of copies as long as the original LICENSE file
 and authors copyright notice are left as they are in the project files.
* Copyright notice could be included ones or multiple times within the file.
* Copyright notice should not be removed even within the larger works (Larger modifications applied).
* Original file tags cannot be removed without creators exclusive permission.
* Adding own tags in files is possible in case of modification - even in that case original tags must be kept.
* Year on the copyright notice breakdown:
* Generally, the “year of first publication of the work” refers to the year in which the work was first distributed to the public (first year mentioned)
* Any year after represents the year of added modifications.
* Copyright cannot expire so therefore you cannot remove copyright notice if its not updated to the latest year.
* Editing existing copyright notice(s) is also prohibited.

===================================================================================
Removing copyright notice & distributing, using or selling the software without
the original license and copyright notice is licence agreement breach and its considered criminal offense and piracy.
===================================================================================

*/



let Utils = require("../app/utils.js"),
	CONFIG = require("../app/SETTINGS/config.js"),
	logcolors = require("console-master");
	f={}
	

f.getBadges = (SENDER,n,callback) =>
{
	
Utils.getBadges(SENDER.getSteamID64(), (ERR, DATA, CURRENTLEVEL, XPNEEDED) => {
	var response;
	
                  logcolors.true('| [Refloow] |: Finished processing !level request, fun fact user is level ' + CURRENTLEVEL);
                    if (!ERR) {
                        if (DATA) {
                            if (n > CURRENTLEVEL) {
                                let s = 0,
                                    l = 0;
                                for (let i = 0; i < (n - CURRENTLEVEL); i++) {
                                    s += parseInt((CURRENTLEVEL + l) / 10) + 1;
                                    l++;
                                }
								
                                 response= "/pre ✔️ To get to level " + n + " you will need " + (s - Math.floor(XPNEEDED / 100)) + " sets. That would cost " + Math.floor(parseInt((s - Math.floor(XPNEEDED / 100)) / CONFIG.CARDS.BUY1KEYFORAMOUNTOFSETS * 100) / 100) + " CS:GO keys OR " + Math.floor(parseInt((s - Math.floor(XPNEEDED / 100)) / CONFIG.CARDS.BUY1KEYFORAMOUNTOFSETSTF2 * 100) / 100) + " TF2 keys OR " + Math.floor(parseInt((s - Math.floor(XPNEEDED / 100)) * CONFIG.CARDS.BUY1GEMSFORAMOUNTOFSETS * 100) / 100) + " Gems.";
								
								
                            } else {
                                response= "/pre ⚠️ Please provide a valid level.";
                            }
                        } else {
                            response= "/pre ⚠️ Your level could not be retrieved. Make sure your Steam Profile is public and try again.";
                        }
                    } else {
                        logcolors.fail("| [Steam] |: An error occurred while getting badge data: " + ERR);
                        response= "/pre ⚠️ An error occurred while loading your badges. Please try again later.";
						
						
                    }
					
				callback(response);
					
					
                });
				
};

f.MaxSets = (DATA,botSets,callback) => {
    hisMaxSets=0;
    botNSets=0;
    if(!DATA) console.log("/pre Your badges are empty, sending an offer without checking badges.");

    for(let i=0; i<Object.keys(botSets).length;i++)
    {
        if(Object.keys(DATA).indexOf(Object.keys(botSets)[i]) > 0)
        {
          let setsLeft = 5 - DATA[Object.keys(botSets)[i]];
            if(setsLeft > 0 ) hisMaxSets+= Math.min(setsLeft,botSets[Object.keys(botSets)[i]].length)
        }
        else hisMaxSets+= Math.min(5,botSets[Object.keys(botSets)[i]].length);
        botNSets += botSets[Object.keys(botSets)[i]].length;
    }

    callback(hisMaxSets,botNSets,DATA);
		  
};

f.getHisKeys = (n,manager,SENDER,appid,contextid,botSets,amountofsets,setsThatShouldntBeSent,refloow,marketName,MSG,callback) =>
{
	let response;
	if (!isNaN(n) && parseInt(n) > 0) {
        if (n <= CONFIG.MAXBUY) {
            let t = manager.createOffer(SENDER.getSteamID64());
            t.getUserDetails((ERR, ME, THEM) => {
                if (ERR) {
                    logcolors.fail("| [Debug] |: An error occurred while getting trade holds: " + ERR);
                    refloow.chatMessage(SENDER,"/pre ⚠️ An error occurred while getting your trade holds. Please try again");
                } else if (ME.escrowDays == 0 && THEM.escrowDays == 0) {
                    n = parseInt(n);
                    
                    logcolors.true('| [Refloow] |: Processing of request');
                    refloow.chatMessage(SENDER,"/me Processing your request.");
                    manager.getUserInventoryContents(SENDER.getSteamID64(), appid, contextid, true, (ERR, INV, CURR) => {
                        
                    let theirKeys = [];
                    

                        if (ERR) {
                            logcolors.fail("| [Inventory] |: An error occurred while getting inventory: " + ERR);
                            refloow.chatMessage(SENDER,"/pre ⚠️ An error occurred while loading your inventory. Please try later");
                        } else {
                            logcolors.info("| [Debug] |: Inventory Loaded");
                            if (!ERR) {
                                logcolors.info("| [Debug] |: Inventory Loaded 2");
                                for (let i = 0; i < INV.length; i++) {
                                    if (theirKeys.length < n && marketName.indexOf(INV[i].market_hash_name) >= 0) {
                                        theirKeys.push(INV[i]);
                                    }
                                }
                                if (theirKeys.length != n) {
                                    refloow.chatMessage(SENDER,"/pre ⚠️ You do not have enough keys.");
                                } else {
                                    Utils.getBadges(SENDER.getSteamID64(), (ERR, DATA) => {
                                        if (!ERR) {
                                            logcolors.info("| [Debug] |: DEBUG#BADGE LOADED");
                                            if (!ERR) {	
                                                f.MaxSets(DATA,botSets, (hisMaxSets,botNSets,b) =>
                                                {
                                                logcolors.info("| [Debug] |: Loop 2 DONE");
                                                // HERE
                                                if (amountofsets <= hisMaxSets) {
                                                    hisMaxSets = amountofsets;
                                                    logcolors.info("| [Debug] |: Trade Created");
                                                    sortSetsByAmount(botSets, (DATA) => {
                                                        logcolors.info("| [Debug] |:" + DATA);
                                                        logcolors.info("| [Debug] |: Sets Sorted");
                                                        firstLoop: for (let i = 0; i < DATA.length; i++) {
                                                            
                                                            //DATA values = appids , eg DATA[i] = 730
                                                            if (b[DATA[i]] >= 5) {
                                                                
                                                                continue firstLoop;
                                                            } else {
                                                                
                                                                logcolors.info("| [Debug] |: DEBUG#" + i);
                                                                logcolors.info("| [Debug] |: DEBUG FOR LOOP ITEMS");
                                                                if (hisMaxSets > 0) {
                                                                    logcolors.info("| [Debug] |: DEBUG# MAXSETSMORETHAN1");
                                                                    if (b[DATA[i]] && botSets[DATA[i]].length >= 5 - b[DATA[i]]) {
                                                                        
                                                                        // BOT HAS ENOUGH SETS OF THIS KIND
                                                                        logcolors.info("| [Debug] |: Loop 1");
                                                                        sLoop: for (let j = 0; j < 5-b[DATA[i]]; j++) {
                                                                                if(hisMaxSets>0)
                                                                                {
                                                                                logcolors.info("| [Debug] |: loop #1 CONTINUE: ITEM ADD");
                                                                                logcolors.info("| [Debug] |: DEBUG#LOOP #1: " + botSets[DATA[i]][j]);
                                                                                t.addMyItems(botSets[DATA[i]][j]);
                                                                                hisMaxSets--;
                                                                                }
                                                                                
                                                                            
                                                                        }
                                                                    } else if (b[DATA[i]] && botSets[DATA[i]].length < 5-b[DATA[i]]) {
                                                                        // BOT DOESNT HAVE ENOUGH SETS OF THIS KIND
                                                                        
                                                                                
                                                                        sLoop: for (let j = 0; j < botSets[DATA[i]].length; j++) {
                                                                            if(hisMaxSets>0){
                                                                                logcolors.info("| [Debug] |: loop #1 CONTINUE: ITEM ADD");
                                                                                logcolors.info("| [Debug] |: DEBUG#LOOP #1: " + botSets[DATA[i]][j]);
                                                                                t.addMyItems(botSets[DATA[i]][j]);
                                                                                hisMaxSets--;
                                                                        }
                                                                            
                                                                        } // *
                                                                    } else if (!b[DATA[i]]) { // TODO NOT FOR LOOP WITH BOTSETS. IT SENDS ALL
                                                                        // BOT HAS ENOUGH SETS AND USER NEVER CRAFTED THIS
                                                                        
                                                                        bLoop: for (let j = 0; j < Math.min(5,botSets[DATA[i]].length); j++) {
                                                                           if(botSets[DATA[i]][j] && hisMaxSets>0)
                                                                                {
                                                                                t.addMyItems(botSets[DATA[i]][j]);
                                                                                logcolors.info("| [Debug] |: loop #2 CONTINUE: ITEM ADD");
                                                                                hisMaxSets--;
                                                                        }
                                                                            
                                                                        }
                                                                    }
                                                                    
                                                                } else {
                                                                    logcolors.info("| [Debug] |: RETURN");
                                                                    break firstLoop;
                                                                }
                                                            }
                                                        }
                                                        if (hisMaxSets > 0) {
                                                            refloow.chatMessage(SENDER,"/pre ⚠️ There are not enough sets. Please try again later.");
                                                        } else {
                                                            logcolors.info("| [Debug] |: -SENDING");
                                                            t.addTheirItems(theirKeys);
                                                            t.data("commandused", MSG);
                                                            t.data("quantity", n);
                                                            t.data("amountofsets", amountofsets.toString());
                                                            t.data("index", setsThatShouldntBeSent.length);
                                                            setsThatShouldntBeSent.push(t.itemsToGive);
                                                            t.send((ERR, STATUS) => {
                                                                if (ERR) {
                                                                   refloow.chatMessage(SENDER,"/pre ⚠️ An error occurred while sending your trade. Steam Trades could be down. Please try again later.");
                                                                    logcolors.fail("| [Steam] |: An error occurred while sending trade: " + ERR);
                                                                    
                                                                } else {
                                                                    refloow.chatMessage(SENDER, "/me ✔️ Trade Sent! Confirming it...");
                                                                    logcolors.info("| [Steam] |: Trade offer sent!");
                                                                logcolors.summary("| [Summary] |: Bot sent "+ amountofsets + " set(s) for their " + n +" key(s)");
                                                                    
                                                                }
                                                                
                                                            });
                                                        }
                                                        
                                                    });
                                                } else {
                                                    
                                                    refloow.chatMessage(SENDER,"/pre ⚠️ There are currently not enough sets that you have not used in stock for this amount of keys.");
                                                    
                                                    
                                                }
                                                }); // TO HERE
                                            } else {
                                                logcolors.fail(SENDER, "| [Steam] |: An error occurred while getting badges: " + ERR);
                                                
                                            }
                                        } else {
                                            refloow.chatMessage(SENDER,"/pre ⚠️ An error occurred while getting your badges. Please try again.");
                                            logcolors.fail(SENDER, "| [Steam] |: An error occurred while loading badges: " + ERR);
                                            
                                            
                                        }
                                        
                                    });
                                }
                            }
                            
                            else {
                                logcolors.fail("| [Inventory] |: An error occurred while getting inventory: " + ERR);
                                response= "/pre ⚠️ An error occurred while loading your inventory, please make sure it's set to public.";
                            }
                        }
                        
                    });
                    } else {
                    refloow.chatMessage(SENDER,"/pre ⚠️ Please make sure you don't have a trade hold!");
                    
                }
            });
            
            }
                
            else {
            refloow.chatMessage(SENDER,"/pre ⚠️ Please try a lower amount of keys. This bot only sells " + CONFIG.MAXBUY + " keys at a time.");
            
        }
        
    } else {
        refloow.chatMessage(SENDER,"/pre ⚠️ Please provide a valid amount of keys.");
        
        
    }
    callback(null);
    
    
};

f.getHisSets = (n,manager,SENDER,appid,contextid,botSets,amountofsets,setsThatShouldntBeSent,refloow,marketName,community,allCards,MSG,callback) =>
{
	let response;
	if (!isNaN(n) && parseInt(n) > 0) {
                    if (n <= CONFIG.MAXSELL) {
                      logcolors.true('| [Refloow] |: Processing of request');
                        refloow.chatMessage(SENDER, "/me ✔️ Processing your request.");
                        let botKeys = [],
                            t = manager.createOffer(SENDER.getSteamID64());
                        t.getUserDetails((ERR, ME, THEM) => {
                            if (ERR) {
                                logcolors.fail("| [Debug] |: An error occurred while getting trade holds: " + ERR);
                                refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while getting your trade holds. Please try again");
                            } else if (ME.escrowDays == 0 && THEM.escrowDays == 0) {
                                manager.getUserInventoryContents(refloow.steamID.getSteamID64(), appid, contextid, true, (ERR, INV, CURR) => {
                                    if (ERR) {
                                        logcolors.fail("| [Steam] |: An error occurred while getting bot inventory: " + ERR);
                                        refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while loading the bot's inventory. Please try again.");
                                    } else {
                                        for (let i = 0; i < INV.length; i++) {
                                            if (botKeys.length < n && marketName.indexOf(INV[i].market_hash_name) >= 0) {
                                                botKeys.push(INV[i]);
                                            }
                                        }
                                        if (botKeys.length != n) {
                                            refloow.chatMessage(SENDER, "/pre ⚠️ The bot does not have enough keys.");
                                        } else {
                                            let amountofB = amountofsets;
                                            Utils.getInventory(SENDER.getSteamID64(), community, (ERR, DATA) => {
                                                if (!ERR) {
                                                    let s = DATA;
                                                    Utils.getSets(s, allCards, (ERR, DDATA) => {
                                                        if (!ERR) {
                                                            sortSetsByAmountB(DDATA, (DATA) => {										
                                                                let setsSent = {};
                                                                firsttLoop: for (let i = 0; i < DATA.length; i++) {
                                                                   // console.log(setsSent);
                                                                   // console.log(DATA[i]);
																   var loop;
                                                                    if (DDATA[DATA[i]]) {
																		if(botSets[DATA[i]])
																		{	
																			if(botSets[DATA[i]].length>=CONFIG.MAXSTOCKSETSPERGAME)
																			{
																				continue;
																			}
																			else
																			{
																				var total = botSets[DATA[i]].length + DDATA[DATA[i]].length;
																				if(total>CONFIG.MAXSTOCKSETSPERGAME)
																				{
																					if(DDATA[DATA[i]].length >= CONFIG.MAXSTOCKSETSPERGAME)
																					{
																							loop= CONFIG.MAXSTOCKSETSPERGAME-botSets[DATA[i]].length;
																					}
																					else
																					{
																						var left = CONFIG.MAXSTOCKSETSPERGAME - DDATA[DATA[i]].length;
																						loop = (left>DDATA[DATA[i]].length) ? DDATA[DATA[i]].length:left;
																					}
																				}
																				else
																				{
																					loop=DDATA[DATA[i]].length;
																				}
																			}
																		}
																		else
																		{
																			loop = Math.min(DDATA[DATA[i]].length,CONFIG.MAXSTOCKSETSPERGAME);
																		}
																		//console.log(setsSent[DATA[i]]);
                                                                        for (let j = 0; j < loop; j++) {
																			
																			
                                                                            if (amountofB > 0) {
                                                                                if ((setsSent[DATA[i]] && setsSent[DATA[i]] < CONFIG.MAXSETSELL ) || !setsSent[DATA[i]]) {
																					
																					
                                                                                    t.addTheirItems(DDATA[DATA[i]][j]);
                                                                                    logcolors.info("| [Debug] |: loop #2 CONTINUE: ITEM ADD");
                                                                                    amountofB--;
                                                                                    if (!setsSent[DATA[i]]) {
                                                                                        setsSent[DATA[i]] = 1;
                                                                                    } else {
                                                                                        setsSent[DATA[i]] += 1;
                                                                                    }
																				
                                                                                } else {
                                                                                    logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN");
                                                                                    continue firsttLoop;
                                                                                }
                                                                            } else {
                                                                                logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN");
                                                                                continue firsttLoop;
                                                                            }
																			
                                                                        }
                                                                    } else {
                                                                        logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN 2");
                                                                        continue firsttLoop;
                                                                    }
                                                                }
                                                            });
                                                            if (amountofB > 0) {
                                                                refloow.chatMessage(SENDER, "/pre ⚠️ You do not have enough sets, (this bot only accepts total " + CONFIG.CARDS.MAXSETSELL + " sets at a time and "+ CONFIG.MAXSTOCKSETSPERGAME+" per set type ). Please try again later.");
                                                            } else {
                                                                logcolors.info("| [Debug] |: -SENDING");
                                                                t.addMyItems(botKeys);
                                                                t.data("commandused", MSG);
                                                                t.data("amountofsets", amountofsets.toString());
                                                                t.data("quantity", n);
                                                                t.send((ERR, STATUS) => {
                                                                    if (ERR) {
                                                                        refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while sending your trade. Steam Trades could be down. Please try again later.");
                                                                        logcolors.fail("| [Steam] |: An error occurred while sending trade: " + ERR);
                                                                    } else {
                                                                        refloow.chatMessage(SENDER, "/me ✔️ Trade Sent! Confirming it...");
                                                                        logcolors.info("| [Steam] |: Trade offer sent!");
																		logcolors.summary("| [Summary] |: Bot sent " +n + " key(s) for their " + amountofsets +" set(s)");
                                                                    }
                                                                });
                                                            }
                                                        } else {
                                                            logcolors.fail("| [Inventory] |: An error occurred while getting bot sets: " + ERR);
                                                        }
                                                    });
                                                } else {
                                                    logcolors.fail("| [Inventory] |: An error occurred while loading user inventory: " + ERR);
                                                }
                                            });
                                        }
                                    }
                                });
                            } else {
                                refloow.chatMessage(SENDER, "/pre ⚠️ Please make sure you don't have a trade hold!");
                            }
                        });
                    } else {
                        refloow.chatMessage(SENDER, "/pre ⚠️ Please try a lower amount of keys.");
                    }
                } else {
                    refloow.chatMessage(SENDER, "/pre ⚠️ Please enter a valid amount of keys!");
                }
			
			
};

f.donateSets = (n,manager,SENDER,amountofsets,setsThatShouldntBeSent,refloow,community,allCards,callback) =>
{
	if (!isNaN(n) && parseInt(n) > 0) {
					if (n <= CONFIG.MAXSELL) {
						refloow.chatMessage(SENDER, "/me Processing your request.");
						let botKeys = [],
							t = manager.createOffer(SENDER.getSteamID64());
						t.getUserDetails((ERR, ME, THEM) => {
						logcolors.true('| [Refloow] |: Processing !donatesets request...');
							if (ERR) {
								logcolors.fail("| [Debug] |: An error occurred while getting trade holds: " + ERR);
								refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while getting your trade holds. Please try again");
							} else if (ME.escrowDays == 0 && THEM.escrowDays == 0) {
								manager.getUserInventoryContents(refloow.steamID.getSteamID64(), CONFIG.KEYSFROMGAME, 2, true, (ERR, INV, CURR) => {
									if (ERR) {
										logcolors.fail("| [Inventory] | An error occurred while getting bot inventory: " + ERR);
										refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while loading the bot's inventory. Please try again.");
									} else {
										let amountofB = amountofsets;
											Utils.getInventory(SENDER.getSteamID64(), community, (ERR, DATA) => {
												if (!ERR) {
													let s = DATA;
													Utils.getSets(s, allCards, (ERR, DDATA) => {
														if (!ERR) {
															sortSetsByAmountB(s, (DATA) => {
																let setsSent = {};
																firsttLoop: for (let i = 0; i < DATA.length; i++) {
																	if (DDATA[DATA[i]]) {
																		for (let j = 0; j < DDATA[DATA[i]].length; j++) {
																			if (amountofB > 0) {
																				if ((setsSent[DATA[i]] && setsSent[DATA[i]] < CONFIG.CARDS.MAXSETSELL) || !setsSent[DATA[i]]) {
																					t.addTheirItems(DDATA[DATA[i]][j]);
																					logcolors.info("| [Debug] |: loop #2 CONTINUE: ITEM ADD");
																					amountofB--;
																					if (!setsSent[DATA[i]]) {
																						setsSent[DATA[i]] = 1;
																					} else {
																						setsSent[DATA[i]] += 1;
																					}
																				} else {
																					logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN");
																					continue firsttLoop;
																				}
																			} else {
																				logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN");
																				continue firsttLoop;
																			}
																		}
																	} else {
																		logcolors.info("| [Debug] |: loop #2 CONTINUE: RETURN 2");
																		continue firsttLoop;
																	}
																}
															});
															if (amountofB > 0) {
																refloow.chatMessage(SENDER, "/pre ⚠️ You do not have enough sets, (this bot only keeps total " + CONFIG.MAXSTOCKSETSPERGAME+" games in stock at a time). Please try again later.");
															} else {
																logcolors.info("| [Debug] |: -SENDING");
																t.addMyItems(botKeys);
																t.data("commandused", "Sell");
																t.data("amountofsets", amountofsets.toString());
																t.data("amountofkeys", n);
																t.send((ERR, STATUS) => {
																	if (ERR) {
																		refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while sending your trade. Steam Trades could be down. Please try again later.");
																		logcolors.fail("| [Steam] |: An error occurred while sending trade: " + ERR);
																	} else {
																		refloow.chatMessage(SENDER, "/me ✔️ Trade Sent! Confirming it...");
																		logcolors.info("| [Steam] |: Trade offer sent!");
																	}
																});
															}
														} else {
															logcolors.fail("| [Inventory] |: An error occurred while getting bot sets: " + ERR);
														}
													});
												} else {
													logcolors.fail("| [Steam] |: An error occurred while getting user inventory: " + ERR);
												}
											});
									}
								});
							} else {
								refloow.chatMessage(SENDER, "/pre ⚠️ Please make sure you don't have a trade hold!");
							}
						});
					} else {
						refloow.chatMessage(SENDER, "/pre ⚠️ Please try a lower amount of sets.");
					}
				} else {
					refloow.chatMessage(SENDER, "/pre ⚠️ Please enter a valid amount of sets.");
				}
		};

f.getCurrencyStocks = (manager,SENDER,refloow) => {
	let csgo=0,
	tf=0,
	hydra =0,
	gems=0;
	manager.getInventoryContents(730, 2, true, (ERR, INV, CURR) => {
		if(ERR)
		{
			logcolors.fail(" |DEBUG|: An error occurred while getting bot inventory: " + ERR);
			refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while loading the bot's inventory. Please try again.");
		}
		else
		{
			
			for( let i=0 ;i<INV.length;i++)
			{
				if(CONFIG.ACCEPTEDKEYS.indexOf(INV[i].market_hash_name) >= 0)
					csgo++;
				else if(CONFIG.HYDRAKEY.indexOf(INV[i].market_hash_name) >=0)
					hydra++;
			}
		}


	manager.getInventoryContents(440, 2, true, (ERR, INV, CURR) => {
		if(ERR)
		{
			logcolors.fail(" |DEBUG|: An error occurred while getting bot inventory: " + ERR);
			refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while loading the bot's inventory. Please try again.");
		}
		else
		{
			for( let i=0 ;i<INV.length;i++)
			{
				if(CONFIG.TF2KEY.indexOf(INV[i].market_hash_name) >= 0)
					tf++;
			}
		}


	manager.getInventoryContents(753, 6, true, (ERR, INV, CURR) => {
		if(ERR)
		{
			logcolors.fail(" |DEBUG|: An error occurred while getting bots inventory: " + ERR);
			refloow.chatMessage(SENDER, "/pre ⚠️ An error occurred while loading the bot's inventory. Please try again.");
		}
		else
		{
			
			INV = INV.filter((ITEM) => ITEM.getTag("item_class").internal_name == "item_class_7");
			if(INV[0]!=null)
				gems=INV[0].amount;
		}
	
	refloow.chatMessage(SENDER,"/pre I currently have -\n" + csgo + " csgo keys\n" + hydra + " hydra keys\n" + tf + " tf2 keys\n" + gems + " gems");
	logcolors.info("| [Refloow] | Bot has " + csgo + " csgo keys " + hydra + " hydra keys " + tf + " tf2 keys " + gems + " gems");
});
	});
	});
};

f.levelReached = (n,currency,CURRENTLEVEL,callback) =>
{
	let amountOfSets=n * currency;
				let sets=amountOfSets;
				let base = parseInt(CURRENTLEVEL/10) + 1
				let level;
			for(level =CURRENTLEVEL;amountOfSets>0 && amountOfSets>base;level++)
				{
					
					amountOfSets-=base;

					if(level%10==0)
					{
						base++;
					}
						
				}
		callback(level);
};



function sortSetsByAmount(SETS, callback) {
    callback(Object.keys(SETS).sort((k1, k2) => SETS[k1].length - SETS[k2].length).reverse());
}

function sortSetsByAmountB(SETS, callback) {
    callback(Object.keys(SETS).sort((k1, k2) => SETS[k1].length - SETS[k2].length));
}

module.exports=f;

// Copyright notice:

/* Original work: Copyright (c) 2020-2021 Refloow All rights reserved.
  Code origin (Free GitHub publish): https://github.com/OSL-Works/Steam-Card-Bot-PRO*/

